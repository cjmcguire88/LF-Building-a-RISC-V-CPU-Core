// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar dmem, imem, xreg;


//
// Signals declared top-level.
//

// For $br_tgt_pc.
logic [31:0] L0_br_tgt_pc_a0;

// For $dec_bits.
logic [10:0] L0_dec_bits_a0;

// For $dmem1_addr.
logic [$clog2(32)-1:0] L0_dmem1_addr_a0;

// For $dmem1_rd_en.
logic L0_dmem1_rd_en_a0;

// For $dmem1_wr_data.
logic [32-1:0] L0_dmem1_wr_data_a0;

// For $dmem1_wr_en.
logic L0_dmem1_wr_en_a0;

// For $funct3.
logic [2:0] L0_funct3_a0;

// For $funct3_valid.
logic L0_funct3_valid_a0;

// For $imm.
logic [31:0] L0_imm_a0;

// For $imm_valid.
logic L0_imm_valid_a0;

// For $instr.
logic [31:0] L0_instr_a0;

// For $is_add.
logic L0_is_add_a0;

// For $is_addi.
logic L0_is_addi_a0;

// For $is_and.
logic L0_is_and_a0;

// For $is_andi.
logic L0_is_andi_a0;

// For $is_auipc.
logic L0_is_auipc_a0;

// For $is_b_instr.
logic L0_is_b_instr_a0;

// For $is_beq.
logic L0_is_beq_a0;

// For $is_bge.
logic L0_is_bge_a0;

// For $is_bgeu.
logic L0_is_bgeu_a0;

// For $is_blt.
logic L0_is_blt_a0;

// For $is_bltu.
logic L0_is_bltu_a0;

// For $is_bne.
logic L0_is_bne_a0;

// For $is_i_instr.
logic L0_is_i_instr_a0;

// For $is_j_instr.
logic L0_is_j_instr_a0;

// For $is_jal.
logic L0_is_jal_a0;

// For $is_jalr.
logic L0_is_jalr_a0;

// For $is_load.
logic L0_is_load_a0;

// For $is_lui.
logic L0_is_lui_a0;

// For $is_or.
logic L0_is_or_a0;

// For $is_ori.
logic L0_is_ori_a0;

// For $is_r_instr.
logic L0_is_r_instr_a0;

// For $is_s_instr.
logic L0_is_s_instr_a0;

// For $is_sll.
logic L0_is_sll_a0;

// For $is_slli.
logic L0_is_slli_a0;

// For $is_slt.
logic L0_is_slt_a0;

// For $is_slti.
logic L0_is_slti_a0;

// For $is_sltiu.
logic L0_is_sltiu_a0;

// For $is_sltu.
logic L0_is_sltu_a0;

// For $is_sra.
logic L0_is_sra_a0;

// For $is_srai.
logic L0_is_srai_a0;

// For $is_srl.
logic L0_is_srl_a0;

// For $is_srli.
logic L0_is_srli_a0;

// For $is_sub.
logic L0_is_sub_a0;

// For $is_u_instr.
logic L0_is_u_instr_a0;

// For $is_xor.
logic L0_is_xor_a0;

// For $is_xori.
logic L0_is_xori_a0;

// For $jalr_tgt_pc.
logic [31:0] L0_jalr_tgt_pc_a0;

// For $ld_data.
logic [32-1:0] L0_ld_data_a0;

// For $next_pc.
logic [31:0] L0_next_pc_a0,
             L0_next_pc_a1;

// For $opcode.
logic [6:0] L0_opcode_a0;

// For $pc.
logic [31:0] L0_pc_a0;

// For $rd.
logic [4:0] L0_rd_a0;

// For $rd_valid.
logic L0_rd_valid_a0;

// For $reset.
logic L0_reset_a0,
      L0_reset_a1;

// For $result.
logic [31:0] L0_result_a0;

// For $rf1_rd_en1.
logic L0_rf1_rd_en1_a0;

// For $rf1_rd_en2.
logic L0_rf1_rd_en2_a0;

// For $rf1_rd_index1.
logic [$clog2(32)-1:0] L0_rf1_rd_index1_a0;

// For $rf1_rd_index2.
logic [$clog2(32)-1:0] L0_rf1_rd_index2_a0;

// For $rf1_wr_data.
logic [32-1:0] L0_rf1_wr_data_a0;

// For $rf1_wr_en.
logic L0_rf1_wr_en_a0;

// For $rf1_wr_index.
logic [$clog2(32)-1:0] L0_rf1_wr_index_a0;

// For $rf_wr_data.
logic [31:0] L0_rf_wr_data_a0;

// For $rs1.
logic [4:0] L0_rs1_a0;

// For $rs1_valid.
logic L0_rs1_valid_a0;

// For $rs2.
logic [4:0] L0_rs2_a0;

// For $rs2_valid.
logic L0_rs2_valid_a0;

// For $sext_src1.
logic [63:0] L0_sext_src1_a0;

// For $sltiu_rslt.
logic [31:0] L0_sltiu_rslt_a0;

// For $sltu_rslt.
logic [31:0] L0_sltu_rslt_a0;

// For $sra_rslt.
logic [63:0] L0_sra_rslt_a0;

// For $srai_rslt.
logic [63:0] L0_srai_rslt_a0;

// For $src1_value.
logic [32-1:0] L0_src1_value_a0;

// For $src2_value.
logic [32-1:0] L0_src2_value_a0;

// For $taken_br.
logic L0_taken_br_a0;

// For /dmem$value.
logic [32-1:0] Dmem_value_n1 [31:0],
               Dmem_value_a0 [31:0];

// For /xreg$value.
logic [32-1:0] Xreg_value_n1 [31:0],
               Xreg_value_a0 [31:0];



   // Staging of $next_pc.
   always_ff @(posedge clk) L0_next_pc_a1[31:0] <= L0_next_pc_a0[31:0];

   // Staging of $reset.
   always_ff @(posedge clk) L0_reset_a1 <= L0_reset_a0;


   //
   // Scope: /dmem[31:0]
   //
   for (dmem = 0; dmem <= 31; dmem++) begin : L1gen_Dmem
      // Staging of $value.
      always_ff @(posedge clk) Dmem_value_a0[dmem][32-1:0] <= Dmem_value_n1[dmem][32-1:0];

   end

   //
   // Scope: /xreg[31:0]
   //
   for (xreg = 0; xreg <= 31; xreg++) begin : L1gen_Xreg
      // Staging of $value.
      always_ff @(posedge clk) Xreg_value_a0[xreg][32-1:0] <= Xreg_value_n1[xreg][32-1:0];

   end




//
// Debug Signals
//

   if (1) begin : DEBUG_SIGS

      logic [31:0] \@0$br_tgt_pc ;
      assign \@0$br_tgt_pc = L0_br_tgt_pc_a0;
      logic [10:0] \@0$dec_bits ;
      assign \@0$dec_bits = L0_dec_bits_a0;
      logic [$clog2(32)-1:0] \@0$dmem1_addr ;
      assign \@0$dmem1_addr = L0_dmem1_addr_a0;
      logic  \@0$dmem1_rd_en ;
      assign \@0$dmem1_rd_en = L0_dmem1_rd_en_a0;
      logic [32-1:0] \@0$dmem1_wr_data ;
      assign \@0$dmem1_wr_data = L0_dmem1_wr_data_a0;
      logic  \@0$dmem1_wr_en ;
      assign \@0$dmem1_wr_en = L0_dmem1_wr_en_a0;
      logic [2:0] \@0$funct3 ;
      assign \@0$funct3 = L0_funct3_a0;
      logic  \@0$funct3_valid ;
      assign \@0$funct3_valid = L0_funct3_valid_a0;
      logic [31:0] \@0$imm ;
      assign \@0$imm = L0_imm_a0;
      logic  \@0$imm_valid ;
      assign \@0$imm_valid = L0_imm_valid_a0;
      logic [31:0] \@0$instr ;
      assign \@0$instr = L0_instr_a0;
      logic  \@0$is_add ;
      assign \@0$is_add = L0_is_add_a0;
      logic  \@0$is_addi ;
      assign \@0$is_addi = L0_is_addi_a0;
      logic  \@0$is_and ;
      assign \@0$is_and = L0_is_and_a0;
      logic  \@0$is_andi ;
      assign \@0$is_andi = L0_is_andi_a0;
      logic  \@0$is_auipc ;
      assign \@0$is_auipc = L0_is_auipc_a0;
      logic  \@0$is_b_instr ;
      assign \@0$is_b_instr = L0_is_b_instr_a0;
      logic  \@0$is_beq ;
      assign \@0$is_beq = L0_is_beq_a0;
      logic  \@0$is_bge ;
      assign \@0$is_bge = L0_is_bge_a0;
      logic  \@0$is_bgeu ;
      assign \@0$is_bgeu = L0_is_bgeu_a0;
      logic  \@0$is_blt ;
      assign \@0$is_blt = L0_is_blt_a0;
      logic  \@0$is_bltu ;
      assign \@0$is_bltu = L0_is_bltu_a0;
      logic  \@0$is_bne ;
      assign \@0$is_bne = L0_is_bne_a0;
      logic  \@0$is_i_instr ;
      assign \@0$is_i_instr = L0_is_i_instr_a0;
      logic  \@0$is_j_instr ;
      assign \@0$is_j_instr = L0_is_j_instr_a0;
      logic  \@0$is_jal ;
      assign \@0$is_jal = L0_is_jal_a0;
      logic  \@0$is_jalr ;
      assign \@0$is_jalr = L0_is_jalr_a0;
      logic  \@0$is_load ;
      assign \@0$is_load = L0_is_load_a0;
      logic  \@0$is_lui ;
      assign \@0$is_lui = L0_is_lui_a0;
      logic  \@0$is_or ;
      assign \@0$is_or = L0_is_or_a0;
      logic  \@0$is_ori ;
      assign \@0$is_ori = L0_is_ori_a0;
      logic  \@0$is_r_instr ;
      assign \@0$is_r_instr = L0_is_r_instr_a0;
      logic  \@0$is_s_instr ;
      assign \@0$is_s_instr = L0_is_s_instr_a0;
      logic  \@0$is_sll ;
      assign \@0$is_sll = L0_is_sll_a0;
      logic  \@0$is_slli ;
      assign \@0$is_slli = L0_is_slli_a0;
      logic  \@0$is_slt ;
      assign \@0$is_slt = L0_is_slt_a0;
      logic  \@0$is_slti ;
      assign \@0$is_slti = L0_is_slti_a0;
      logic  \@0$is_sltiu ;
      assign \@0$is_sltiu = L0_is_sltiu_a0;
      logic  \@0$is_sltu ;
      assign \@0$is_sltu = L0_is_sltu_a0;
      logic  \@0$is_sra ;
      assign \@0$is_sra = L0_is_sra_a0;
      logic  \@0$is_srai ;
      assign \@0$is_srai = L0_is_srai_a0;
      logic  \@0$is_srl ;
      assign \@0$is_srl = L0_is_srl_a0;
      logic  \@0$is_srli ;
      assign \@0$is_srli = L0_is_srli_a0;
      logic  \@0$is_sub ;
      assign \@0$is_sub = L0_is_sub_a0;
      logic  \@0$is_u_instr ;
      assign \@0$is_u_instr = L0_is_u_instr_a0;
      logic  \@0$is_xor ;
      assign \@0$is_xor = L0_is_xor_a0;
      logic  \@0$is_xori ;
      assign \@0$is_xori = L0_is_xori_a0;
      logic [31:0] \@0$jalr_tgt_pc ;
      assign \@0$jalr_tgt_pc = L0_jalr_tgt_pc_a0;
      logic [32-1:0] \@0$ld_data ;
      assign \@0$ld_data = L0_ld_data_a0;
      logic [31:0] \@0$next_pc ;
      assign \@0$next_pc = L0_next_pc_a0;
      logic [6:0] \@0$opcode ;
      assign \@0$opcode = L0_opcode_a0;
      logic [31:0] \@0$pc ;
      assign \@0$pc = L0_pc_a0;
      logic [4:0] \@0$rd ;
      assign \@0$rd = L0_rd_a0;
      logic  \@0$rd_valid ;
      assign \@0$rd_valid = L0_rd_valid_a0;
      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;
      logic [31:0] \@0$result ;
      assign \@0$result = L0_result_a0;
      logic  \@0$rf1_rd_en1 ;
      assign \@0$rf1_rd_en1 = L0_rf1_rd_en1_a0;
      logic  \@0$rf1_rd_en2 ;
      assign \@0$rf1_rd_en2 = L0_rf1_rd_en2_a0;
      logic [$clog2(32)-1:0] \@0$rf1_rd_index1 ;
      assign \@0$rf1_rd_index1 = L0_rf1_rd_index1_a0;
      logic [$clog2(32)-1:0] \@0$rf1_rd_index2 ;
      assign \@0$rf1_rd_index2 = L0_rf1_rd_index2_a0;
      logic [32-1:0] \@0$rf1_wr_data ;
      assign \@0$rf1_wr_data = L0_rf1_wr_data_a0;
      logic  \@0$rf1_wr_en ;
      assign \@0$rf1_wr_en = L0_rf1_wr_en_a0;
      logic [$clog2(32)-1:0] \@0$rf1_wr_index ;
      assign \@0$rf1_wr_index = L0_rf1_wr_index_a0;
      logic [31:0] \@0$rf_wr_data ;
      assign \@0$rf_wr_data = L0_rf_wr_data_a0;
      logic [4:0] \@0$rs1 ;
      assign \@0$rs1 = L0_rs1_a0;
      logic  \@0$rs1_valid ;
      assign \@0$rs1_valid = L0_rs1_valid_a0;
      logic [4:0] \@0$rs2 ;
      assign \@0$rs2 = L0_rs2_a0;
      logic  \@0$rs2_valid ;
      assign \@0$rs2_valid = L0_rs2_valid_a0;
      logic [63:0] \@0$sext_src1 ;
      assign \@0$sext_src1 = L0_sext_src1_a0;
      logic [31:0] \@0$sltiu_rslt ;
      assign \@0$sltiu_rslt = L0_sltiu_rslt_a0;
      logic [31:0] \@0$sltu_rslt ;
      assign \@0$sltu_rslt = L0_sltu_rslt_a0;
      logic [63:0] \@0$sra_rslt ;
      assign \@0$sra_rslt = L0_sra_rslt_a0;
      logic [63:0] \@0$srai_rslt ;
      assign \@0$srai_rslt = L0_srai_rslt_a0;
      logic [32-1:0] \@0$src1_value ;
      assign \@0$src1_value = L0_src1_value_a0;
      logic [32-1:0] \@0$src2_value ;
      assign \@0$src2_value = L0_src2_value_a0;
      logic  \@0$taken_br ;
      assign \@0$taken_br = L0_taken_br_a0;

      //
      // Scope: /dmem[31:0]
      //
      for (dmem = 0; dmem <= 31; dmem++) begin : \/dmem 
         logic [32-1:0] \/@-1$value ;
         assign \/@-1$value = Dmem_value_n1[dmem];
         logic  \/@0$wr ;
         assign \/@0$wr = L1_Dmem[dmem].L1_wr_a0;
      end

      //
      // Scope: /xreg[31:0]
      //
      for (xreg = 0; xreg <= 31; xreg++) begin : \/xreg 
         logic [32-1:0] \/@-1$value ;
         assign \/@-1$value = Xreg_value_n1[xreg];
         logic  \/@0$wr ;
         assign \/@0$wr = L1_Xreg[xreg].L1_wr_a0;
      end


   end

